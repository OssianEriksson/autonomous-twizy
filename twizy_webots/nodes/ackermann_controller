#!/usr/bin/python3

import rospy

from webots_ros.srv import set_float
from ackermann_msgs.msg import AckermannDriveStamped

from math import tan, atan
import twizy_webots.robot


def main():
    # Initialize ROS node
    rospy.init_node('ackermann_controller')

    # Read parameters from ROS parameter server
    drive_wheel_radius = rospy.get_param('~drive_wheel_radius')
    max_forward_speed = rospy.get_param('~max_forward_speed')
    max_reverse_speed = rospy.get_param('~max_reverse_speed')
    max_steering_angle = rospy.get_param('~max_steering_angle')
    wheelbase = rospy.get_param('~wheelbase')
    track = rospy.get_param('~track')
    drive_motor_left = rospy.get_param('~drive_motor_left')
    drive_motor_right = rospy.get_param('~drive_motor_right')
    steering_motor_left = rospy.get_param('~steering_motor_left')
    steering_motor_right = rospy.get_param('~steering_motor_right')
    model = rospy.get_param('twizy_webots/model_name', None)

    robot = twizy_webots.robot.Robot(model)

    steering_device_left = robot.set_position(steering_motor_left)
    steering_device_right = robot.set_position(steering_motor_right)
    drive_device_left = robot.set_velocity(drive_motor_left)
    drive_device_right = robot.set_velocity(drive_motor_right)

    def cb(msg):
        # Clamp value within allowed bounds
        angle = max(min(msg.drive.steering_angle, max_steering_angle),
                    -max_steering_angle)
        speed = max(min(msg.drive.speed, max_forward_speed),
                    -max_reverse_speed) / drive_wheel_radius

        # Ackermann steering
        turning_radius = (wheelbase / tan(angle)
                          ) if abs(angle) > 1e-10 else float('inf')
        angle_l = atan(wheelbase / (turning_radius - track / 2.0))
        angle_r = atan(wheelbase / (turning_radius + track / 2.0))

        if turning_radius > 1e6:
            speed_l = speed_r = speed
        else:
            turning_radius = wheelbase / tan(angle)
            speed_l = speed * (turning_radius - track / 2.0) / turning_radius
            speed_r = speed * (turning_radius + track / 2.0) / turning_radius

        # Set steering angles
        if not steering_device_left(angle_l):
            rospy.logwarn('Unable to set left side steering angle')
        if not steering_device_right(angle_r):
            rospy.logwarn('Unable to set right side steering angle')

        # Set wheel speeds
        if not drive_device_left(speed_l):
            rospy.logwarn('Unable to set left side velocity')
        if not drive_device_right(speed_r):
            rospy.logwarn('Unable to set right side velocity')

    # Subscribe to topic where reference control values will be published
    # Increasing the queue_size will create INSANE amount of accumulative input
    # lag for some reason (took way too long to figure that out...)
    rospy.Subscriber('ackermann_cmd', AckermannDriveStamped, cb, queue_size=1)

    # Wait for shutdown
    try:
        rospy.spin()
    except rospy.ROSInterruptException:
        pass


if __name__ == '__main__':
    main()
