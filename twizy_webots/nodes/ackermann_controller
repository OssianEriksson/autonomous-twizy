#!/usr/bin/python3

import rospy

from webots_ros.srv import set_float
from ackermann_msgs.msg import AckermannDriveStamped

from math import tan, atan
import twizy_webots.robot


def main():
    # Initialize ROS node
    rospy.init_node('twizy_controller')

    # Read parameters from ROS parameter server
    drive_wheel_radius = rospy.get_param('~drive_wheel_radius')
    max_forward_speed = rospy.get_param('~max_forward_speed')
    max_reverse_speed = rospy.get_param('~max_reverse_speed')
    max_steering_angle = rospy.get_param('~max_steering_angle')
    wheelbase = rospy.get_param('~wheelbase')
    track = rospy.get_param('~track')
    drive_motors = rospy.get_param('~drive_motors')
    steering_motor_left = rospy.get_param('~steering_motor_left')
    steering_motor_right = rospy.get_param('~steering_motor_right')
    model = rospy.get_param('twizy_webots/model_name', None)

    robot = twizy_webots.robot.Robot(model)

    steering_device_left = robot.set_position(steering_motor_left)
    steering_device_right = robot.set_position(steering_motor_right)
    drive_devices = [robot.set_velocity(device) for device in drive_motors]

    def cb(msg):
        # Clamp value within allowed bounds
        angle = max(min(msg.drive.steering_angle, max_steering_angle),
                    -max_steering_angle)
        speed = max(min(msg.drive.speed, max_forward_speed),
                    -max_reverse_speed)

        # Ackermann steering
        centerline_to_intersection = (
            wheelbase / tan(angle)) if abs(angle) > 1e-10 else float('inf')
        angle_l = atan(wheelbase / (centerline_to_intersection - track / 2.0))
        angle_r = atan(wheelbase / (centerline_to_intersection + track / 2.0))

        # Convert from linear to angular velocity
        angular_vel = speed / drive_wheel_radius

        # Set steering angles
        if not steering_device_left(angle_l):
            rospy.logwarn('Unable to set left side steering angle')
        if not steering_device_right(angle_r):
            rospy.logwarn('Unable to set right side steering angle')

        # Set wheel speeds
        for i, drive_device in enumerate(drive_devices):
            if not drive_device(angular_vel):
                rospy.logwarn('Unable to set velocity of device '
                              f'{drive_motors[i]}')

    # Subscribe to topic where reference control values will be published
    # Increasing the queue_size will create INSANE amount of accumulative input
    # lag for some reason (took way too long to figure that out...)
    rospy.Subscriber('ackermann_cmd', AckermannDriveStamped, cb, queue_size=1)

    # Wait for shutdown
    try:
        rospy.spin()
    except rospy.ROSInterruptException:
        pass


if __name__ == '__main__':
    main()
