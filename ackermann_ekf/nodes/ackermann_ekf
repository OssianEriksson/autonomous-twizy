#!/usr/bin/python3

import numpy as np
from transforms3d.euler import euler2quat
import rospy
import tf2_ros
import utm
import threading

from geometry_msgs.msg import TransformStamped
from sensor_msgs.msg import NavSatFix
from nav_msgs.msg import Odometry
from ackermann_ekf.ekf import State, Measurement, EKF


def _parse_covariance(covariance, specified_covariance=np.eye(State.SIZE)):
    covariance = np.asarray(covariance)
    for i in range(covariance.shape[0]):
        if covariance[i, i] < 0 or specified_covariance[i, i] < 0:
            covariance[i, :] = 0.0
            covariance[:, i] = 0.0
            covariance[i, i] = 1e6
    return covariance


class SensorArray:
    def __init__(self, filter, frequency, base_link):
        self.filter = filter
        self.base_link = str(base_link)
        self.update_delay = 1.0 / frequency
        self.buffer = tf2_ros.Buffer()
        self.listener = tf2_ros.TransformListener(self.buffer)
        self.initial_position = None
        self.lock = threading.Lock()

    def process_measurement(self, measurement, fuse):
        with self.lock:
            if self.initial_position is None:
                self.initial_position = [measurement.z[Measurement.IDX_X],
                                         measurement.z[Measurement.IDX_Y],
                                         measurement.z[Measurement.IDX_Z]]
                self.initial_position -= measurement.sensor_position

            measurement.z[Measurement.IDX_X] -= self.initial_position[0]
            measurement.z[Measurement.IDX_Y] -= self.initial_position[1]
            measurement.z[Measurement.IDX_Z] -= self.initial_position[2]

            for i in range(Measurement.SIZE):
                if not fuse[i]:
                    measurement.z[i] = None
                    measurement.R[:, i] = 0.0
                    measurement.R[i, :] = 0.0
                    measurement.R[i, i] = 1e6

            self.filter.process_measurement(measurement)

    def get_transform(self, frame_id, stamp=None, timeout=0.5):
        stamp = rospy.Time.now() if stamp is None else stamp

        try:
            return self.buffer.lookup_transform(
                self.base_link, frame_id, stamp, rospy.Duration(timeout))
        except (tf2_ros.LookupException,
                tf2_ros.ConnectivityException,
                tf2_ros.ExtrapolationException,
                AttributeError) as e:
            rospy.logwarn(str(e))
            return None

    def is_initialized(self):
        return self.initial_position is not None


class Sensor:
    def __init__(self, sensor_array, fuse, static_position):
        self.sensor_array = sensor_array
        self.static_position = static_position
        self.fuse = fuse
        self.last_observed = 0.0
        self.sensor_position = None

    def callback(self, msg):
        time = msg.header.stamp.to_sec()
        measure_after = self.last_observed + self.sensor_array.update_delay
        if time < measure_after:
            return

        if not self.static_position or self.sensor_position is None:
            sensor_position_vec = self.sensor_array.get_transform(
                msg.header.frame_id, msg.header.stamp).transform.translation

            self.sensor_position = [sensor_position_vec.x,
                                    sensor_position_vec.y,
                                    sensor_position_vec.z]
        if self.sensor_position is None:
            return

        self.last_observed = time

        z, R = self.get_z_R(msg)

        measurement = Measurement(z, R, time, self.sensor_position)
        self.sensor_array.process_measurement(measurement, self.fuse)


class NavSatFixSensor(Sensor):
    def __init__(self, sensor_array, fuse, static_position):
        super().__init__(sensor_array, fuse, static_position)

        self.fuse[Measurement.IDX_dx_dt] = False
        self.fuse[Measurement.IDX_dy_dt] = False
        self.fuse[Measurement.IDX_dz_dt] = False
        self.fuse[Measurement.IDX_d2x_dt2] = False
        self.fuse[Measurement.IDX_d2y_dt2] = False
        self.fuse[Measurement.IDX_d2z_dt2] = False
        self.fuse[Measurement.IDX_ROLL] = False
        self.fuse[Measurement.IDX_PITCH] = False
        self.fuse[Measurement.IDX_YAW] = False
        self.fuse[Measurement.IDX_droll_dt] = False
        self.fuse[Measurement.IDX_dpitch_dt] = False
        self.fuse[Measurement.IDX_dyaw_dt] = False

    def get_z_R(self, msg):
        x, y, *_ = utm.from_latlon(msg.latitude, msg.longitude)
        z = [None] * Measurement.SIZE
        z[Measurement.IDX_X] = x
        z[Measurement.IDX_Y] = y
        z[Measurement.IDX_Z] = msg.altitude

        R = np.zeros((Measurement.SIZE, Measurement.SIZE))

        cov_type = msg.position_covariance_type
        if cov_type == NavSatFix.COVARIANCE_TYPE_UNKNOWN:
            R[Measurement.IDX_X, Measurement.IDX_X] = 1e0
            R[Measurement.IDX_Y, Measurement.IDX_Y] = 1e0
            R[Measurement.IDX_Z, Measurement.IDX_Z] = 1e0
        else:
            cov = msg.position_covariance
            R[Measurement.IDX_X, Measurement.IDX_X] = cov[0]
            R[Measurement.IDX_X, Measurement.IDX_Y] = cov[1]
            R[Measurement.IDX_X, Measurement.IDX_Z] = cov[2]
            R[Measurement.IDX_Y, Measurement.IDX_X] = cov[3]
            R[Measurement.IDX_Y, Measurement.IDX_Y] = cov[4]
            R[Measurement.IDX_Y, Measurement.IDX_Z] = cov[5]
            R[Measurement.IDX_Z, Measurement.IDX_X] = cov[6]
            R[Measurement.IDX_Z, Measurement.IDX_Y] = cov[7]
            R[Measurement.IDX_Z, Measurement.IDX_Z] = cov[8]

        return z, R


def main():
    rospy.init_node('ackermann_ekf')

    world_frame = rospy.get_param('~world_frame', 'map')
    frequency = rospy.get_param('~frequency', 30)
    base_link = rospy.get_param('~base_link', 'base_link')
    sensors = rospy.get_param('~sensors', [])
    initial_x = rospy.get_param('~initial_x', None)
    initial_P = rospy.get_param('~initial_P', None)
    Q = rospy.get_param('~Q', None)
    Q_cutoff = rospy.get_param('~Q_cutoff_frequency', None)
    x_max = rospy.get_param('~x_max', None)
    neg_x_max = None if x_max is None else [-a for a in x_max]
    x_min = rospy.get_param('~x_min', neg_x_max)

    initial_state = State(x=initial_x, P=initial_P)
    ekf = EKF(state=initial_state, Q=Q, Q_cutoff=Q_cutoff,
              time=rospy.Time.now().to_sec(), x_max=x_max, x_min=x_min)
    sensor_array = SensorArray(ekf, frequency, base_link)

    for sensor in sensors:
        queue_size = sensor.get('queue_size', 1)
        fuse = sensor.get('fuse', [True] * Measurement.SIZE)
        static_position = sensor.get('static_position', False)
        type = sensor.get('type', None)

        if type == 'sensor_msgs/NavSatFix':
            device = NavSatFixSensor(sensor_array, fuse, static_position)
        else:
            rospy.logwarn(f'Unknown sensor type {type}, ignoring')
            continue

        rospy.Subscriber(sensor['topic'], NavSatFix,
                         device.callback, queue_size=queue_size)

    br = tf2_ros.TransformBroadcaster()
    t = TransformStamped()
    t.header.frame_id = world_frame
    t.child_frame_id = base_link

    odom_pub = rospy.Publisher('odom', Odometry, queue_size=10)
    odom = Odometry()
    odom.header.frame_id = world_frame
    odom.child_frame_id = base_link

    pose_idx = [State.IDX_X, State.IDX_Y, State.IDX_Z,
                State.IDX_ROLL, State.IDX_PITCH, State.IDX_YAW]
    pose_cov_idx = [(i, j) for i in pose_idx for j in pose_idx]

    last_time = ekf.time
    rate = rospy.Rate(frequency)
    while not rospy.is_shutdown():
        if sensor_array.is_initialized() and ekf.time > last_time:
            x = sensor_array.filter.state.x
            P = sensor_array.filter.state.P
            speed = x[State.IDX_speed]

            q = euler2quat(x[State.IDX_ROLL],
                           x[State.IDX_PITCH],
                           x[State.IDX_YAW])
            t.header.stamp = rospy.Time(ekf.time)
            t.transform.translation.x = x[State.IDX_X]
            t.transform.translation.y = x[State.IDX_Y]
            t.transform.translation.z = x[State.IDX_Z]
            t.transform.rotation.x = q[1]
            t.transform.rotation.y = q[2]
            t.transform.rotation.z = q[3]
            t.transform.rotation.w = q[0]

            br.sendTransform(t)

            odom.pose.pose.position.x = x[State.IDX_X]
            odom.pose.pose.position.y = x[State.IDX_Y]
            odom.pose.pose.position.z = x[State.IDX_Z]
            odom.pose.pose.orientation.x = q[1]
            odom.pose.pose.orientation.y = q[2]
            odom.pose.pose.orientation.z = q[3]
            odom.pose.pose.orientation.w = q[0]
            odom.pose.covariance = [P[i, j] for i, j in pose_cov_idx]

            odom.twist.twist.linear.x = speed
            odom.twist.twist.angular.x = x[State.IDX_droll_dx] * speed
            odom.twist.twist.angular.y = x[State.IDX_dpitch_dx] * speed
            odom.twist.twist.angular.z = x[State.IDX_dyaw_dx] * speed
            # Math is hard... This covariance is just guessed and not rigorous
            # in any way whatsoever: We e.g. use only a diagonal matrix
            odom.twist.covariance = [0.0] * 36
            odom.twist.covariance[0] = P[State.IDX_speed, State.IDX_speed]
            odom.twist.covariance[7] = 1e-6
            odom.twist.covariance[14] = 1e-6
            odom.twist.covariance[21] = P[State.IDX_ROLL, State.IDX_ROLL] * \
                speed**2 + P[State.IDX_speed, State.IDX_speed] * \
                x[State.IDX_ROLL]**2
            odom.twist.covariance[28] = P[State.IDX_PITCH, State.IDX_PITCH] * \
                speed**2 + P[State.IDX_speed, State.IDX_speed] * \
                x[State.IDX_PITCH]**2
            odom.twist.covariance[35] = P[State.IDX_YAW, State.IDX_YAW] * \
                speed**2 + P[State.IDX_speed, State.IDX_speed] * \
                x[State.IDX_YAW]**2

            odom_pub.publish(odom)

            last_time = ekf.time

        rate.sleep()


if __name__ == '__main__':
    main()
